/*
* Audio Cleaner V1 - Created by EAT - Talha
* Description: This After Effects script simplifies your workflow by automatically detecting and removing or isolating silent sections from your layers based on audio amplitude.
* Inspired by existing tools, this version features a clean, user-friendly interface.
*/

// --- Core Logic Functions (Unchanged) ---

function convertAudio() {
    // This function attempts to execute the "Convert Audio to Keyframes" command in multiple languages.
    app.executeCommand(app.findMenuCommandId("Convert Audio to Keyframes"));
    app.executeCommand(app.findMenuCommandId("Audio in Keyframes konvertieren"));
    app.executeCommand(app.findMenuCommandId("Convertir les données audio en images clés"));
    app.executeCommand(app.findMenuCommandId("Converti audio in fotogrammi chiave"));
    app.executeCommand(app.findMenuCommandId("Convertir audio en fotogramas clave"));
    app.executeCommand(app.findMenuCommandId("オーディオをキーフレームに変換"));
    app.executeCommand(app.findMenuCommandId("오디오를 키프레임으로 변환"));
    app.executeCommand(app.findMenuCommandId("Конвертировать аудио в ключевых кадров"));
    app.executeCommand(app.findMenuCommandId("Преобразовать аудио в ключевые кадры"));
    app.executeCommand(app.findMenuCommandId("将音频转换为关键帧"));
    app.executeCommand(app.findMenuCommandId("Converter áudio em quadros-chave"));
}

function calculateKeys() {
    // Analyzes the audio keyframes generated by convertAudio() and returns their times and values.
    var keyTimes = new Array();
    var keyValues = new Array();
    var audioLayer = comp.layer(1); // Assumes the audio null is the top layer
    var sliderProperty = audioLayer.property("ADBE Effect Parade").property("ADBE Slider Control").property("ADBE Slider Control-0001");
    for (var i = 1; i <= sliderProperty.numKeys; i += 1) {
        keyTimes.push(sliderProperty.keyTime(i));
        keyValues.push(sliderProperty.keyValue(i));
    }
    audioLayer.remove(); // Removes the audio null after extracting data
    return [keyTimes, keyValues];
}

function editVideo(keyTimes, keyValues) {
    // Processes the video layer to keep only the parts where sound is above the threshold.
    var inAndOutTimes = new Array();
    var isRun = false;
    var counter = 0;
    var padding = parseInt(slider.value);
    var threshold = parseFloat(slider2.value);
    for (var i = 0; i < keyTimes.length; i += 1) {
        if (!isRun) {
            if (keyValues[i] >= threshold) {
                isRun = true;
                if ((i - padding) >= 0 && keyTimes[i - padding] !== undefined) {
                    inAndOutTimes[inAndOutTimes.length] = keyTimes[i - padding];
                } else {
                    inAndOutTimes[inAndOutTimes.length] = keyTimes[0];
                }
            }
        } else {
            if (keyValues[i] < threshold) {
                counter++;
                if (counter >= padding) {
                    isRun = false;
                    counter = 0;
                    inAndOutTimes[inAndOutTimes.length] = keyTimes[i - 1];
                }
            }
            if (keyValues[i] >= threshold) {
                counter = 0;
            }
        }
    }
    if (isRun && inAndOutTimes.length % 2 !== 0) {
        inAndOutTimes[inAndOutTimes.length] = keyTimes[keyTimes.length -1];
    }

    for (var e = 0; e < inAndOutTimes.length; e += 2) {
        if (inAndOutTimes[e+1] === undefined) continue;
        var currentLayer = layer.duplicate();
        if (inAndOutTimes[e] < inAndOutTimes[e - 1]) {
            currentLayer.inPoint = inAndOutTimes[e - 1];
            currentLayer.outPoint = inAndOutTimes[e + 1];
        } else {
            currentLayer.inPoint = inAndOutTimes[e];
            currentLayer.outPoint = inAndOutTimes[e + 1];
        }
         if (currentLayer.inPoint >= currentLayer.outPoint) { currentLayer.remove(); }
    }
    if (comp.numLayers > 1 || (comp.numLayers === 1 && layer.name !== comp.layer(1).name )) {
        layer.remove();
    }
    
    var startTime = 0;
    for (var z = 1; z <= comp.numLayers; z += 1) {
        var thisLayer = comp.layer(z);
        thisLayer.name = "Segment_" + z;
        thisLayer.startTime = startTime - thisLayer.inPoint;
        startTime = thisLayer.outPoint;
    }
    if (comp.numLayers > 0) {
        comp.workAreaDuration = comp.layer(comp.numLayers).outPoint - comp.layer(1).startTime + comp.layer(1).inPoint;
        app.executeCommand(app.findMenuCommandId("Trim Comp to Work Area"));
        app.executeCommand(2360); // Sequence Layers
    }
}

function editVideoReverse(keyTimes, keyValues) {
    // Processes the video layer to keep only the silent parts.
    var inAndOutTimes = new Array();
    var isRun = false;
    var counter = 0;
    var padding = parseInt(slider.value);
    var threshold = parseFloat(slider2.value);

    var soundSegments = new Array();
    for (var i = 0; i < keyTimes.length; i += 1) {
        if (!isRun) {
            if (keyValues[i] >= threshold) {
                isRun = true;
                if ((i - padding) >= 0 && keyTimes[i - padding] !== undefined) {
                    soundSegments[soundSegments.length] = keyTimes[i - padding];
                } else {
                    soundSegments[soundSegments.length] = keyTimes[0];
                }
            }
        } else {
            if (keyValues[i] < threshold) {
                counter++;
                if (counter >= padding) {
                    isRun = false;
                    counter = 0;
                    soundSegments[soundSegments.length] = keyTimes[i - 1];
                }
            }
            if (keyValues[i] >= threshold) {
                counter = 0;
            }
        }
    }
    if (isRun && soundSegments.length % 2 !== 0) {
        soundSegments[soundSegments.length] = keyTimes[keyTimes.length - 1];
    }

    var lastSilentEnd = keyTimes[0];
    for (var j = 0; j < soundSegments.length; j += 2) {
        if (soundSegments[j] > lastSilentEnd) {
            inAndOutTimes.push(lastSilentEnd, soundSegments[j]);
        }
        if (soundSegments[j+1] !== undefined) {
            lastSilentEnd = soundSegments[j+1];
        } else {
            lastSilentEnd = keyTimes[keyTimes.length - 1];
        }
    }
    if (lastSilentEnd < keyTimes[keyTimes.length -1]) {
        inAndOutTimes.push(lastSilentEnd, keyTimes[keyTimes.length -1]);
    }
    
    for (var e = 0; e < inAndOutTimes.length; e += 2) {
        if (inAndOutTimes[e+1] === undefined || inAndOutTimes[e] >= inAndOutTimes[e+1]) continue;
        var currentLayer = layer.duplicate();
        currentLayer.inPoint = inAndOutTimes[e];
        currentLayer.outPoint = inAndOutTimes[e + 1];
        if (currentLayer.inPoint >= currentLayer.outPoint) { currentLayer.remove(); }
    }
    if (comp.numLayers > 1 || (comp.numLayers === 1 && layer.name !== comp.layer(1).name )) {
      layer.remove();
    }

    var startTime = 0;
    for (var z = 1; z <= comp.numLayers; z += 1) {
        var thisLayer = comp.layer(z);
        thisLayer.name = "Silent_Segment_" + z;
        thisLayer.startTime = startTime - thisLayer.inPoint;
        startTime = thisLayer.outPoint;
    }
    if (comp.numLayers > 0) {
        comp.workAreaDuration = comp.layer(comp.numLayers).outPoint - comp.layer(1).startTime + comp.layer(1).inPoint;
        app.executeCommand(app.findMenuCommandId("Trim Comp to Work Area"));
        app.executeCommand(2360); // Sequence Layers
    }
}

function editVideoNoDelete(keyTimes, keyValues) {
    // Same as editVideo, but doesn't ripple delete, leaving gaps.
    var inAndOutTimes = new Array();
    var isRun = false;
    var counter = 0;
    var padding = parseInt(slider.value);
    var threshold = parseFloat(slider2.value);
    for (var i = 0; i < keyTimes.length; i += 1) {
        if (!isRun) {
            if (keyValues[i] >= threshold) {
                isRun = true;
                if ((i - padding) >= 0 && keyTimes[i - padding] !== undefined) {
                    inAndOutTimes[inAndOutTimes.length] = keyTimes[i - padding];
                } else {
                    inAndOutTimes[inAndOutTimes.length] = keyTimes[0];
                }
            }
        } else {
            if (keyValues[i] < threshold) {
                counter++;
                if (counter >= padding) {
                    isRun = false;
                    counter = 0;
                    inAndOutTimes[inAndOutTimes.length] = keyTimes[i - 1];
                }
            }
            if (keyValues[i] >= threshold) {
                counter = 0;
            }
        }
    }
    if (isRun && inAndOutTimes.length % 2 !== 0) {
        inAndOutTimes[inAndOutTimes.length] = keyTimes[keyTimes.length -1];
    }

    for (var e = 0; e < inAndOutTimes.length; e += 2) {
        if (inAndOutTimes[e+1] === undefined) continue;
        var currentLayer = layer.duplicate();
         if (inAndOutTimes[e] < inAndOutTimes[e - 1]) {
            currentLayer.inPoint = inAndOutTimes[e - 1];
            currentLayer.outPoint = inAndOutTimes[e + 1];
        } else {
            currentLayer.inPoint = inAndOutTimes[e];
            currentLayer.outPoint = inAndOutTimes[e + 1];
        }
        if (currentLayer.inPoint >= currentLayer.outPoint) { currentLayer.remove(); }
    }
    layer.remove();
}

function editVideoReverseNoDelete(keyTimes, keyValues) {
    // Same as editVideoReverse, but doesn't ripple delete.
    var inAndOutTimes = new Array();
    var isRun = false;
    var counter = 0;
    var padding = parseInt(slider.value);
    var threshold = parseFloat(slider2.value);
    
    var soundSegments = new Array();
    for (var i = 0; i < keyTimes.length; i += 1) {
        if (!isRun) {
            if (keyValues[i] >= threshold) {
                isRun = true;
                if ((i - padding) >= 0 && keyTimes[i - padding] !== undefined) {
                    soundSegments[soundSegments.length] = keyTimes[i - padding];
                } else {
                    soundSegments[soundSegments.length] = keyTimes[0];
                }
            }
        } else {
            if (keyValues[i] < threshold) {
                counter++;
                if (counter >= padding) {
                    isRun = false;
                    counter = 0;
                    soundSegments[soundSegments.length] = keyTimes[i - 1];
                }
            }
            if (keyValues[i] >= threshold) {
                counter = 0;
            }
        }
    }
    if (isRun && soundSegments.length % 2 !== 0) {
        soundSegments[soundSegments.length] = keyTimes[keyTimes.length - 1];
    }

    var lastSilentEnd = keyTimes[0];
    for (var j = 0; j < soundSegments.length; j += 2) {
        if (soundSegments[j] > lastSilentEnd) {
            inAndOutTimes.push(lastSilentEnd, soundSegments[j]);
        }
         if (soundSegments[j+1] !== undefined) {
            lastSilentEnd = soundSegments[j+1];
        } else {
            lastSilentEnd = keyTimes[keyTimes.length - 1];
        }
    }
    if (lastSilentEnd < keyTimes[keyTimes.length -1]) {
        inAndOutTimes.push(lastSilentEnd, keyTimes[keyTimes.length -1]);
    }

    for (var e = 0; e < inAndOutTimes.length; e += 2) {
        if (inAndOutTimes[e+1] === undefined || inAndOutTimes[e] >= inAndOutTimes[e+1]) continue;
        var currentLayer = layer.duplicate();
        currentLayer.inPoint = inAndOutTimes[e];
        currentLayer.outPoint = inAndOutTimes[e + 1];
         if (currentLayer.inPoint >= currentLayer.outPoint) { currentLayer.remove(); }
    }
    layer.remove();
}

// --- Global Script Variables ---
var project = app.project;
var comp = project.activeItem;
var layer;

// --- Initial Checks ---
var curItem = app.project.activeItem;
if ((curItem == null) || (!(curItem instanceof CompItem))) {
    alert("Cannot run script on this item. Please select a Composition and run the script again.");
} else {
    comp = curItem;
    if (comp.numLayers < 1) {
        alert("The active composition must have at least one layer to process.");
    } else {
        layer = comp.selectedLayers.length > 0 ? comp.selectedLayers[0] : comp.layer(1);

        app.beginSuppressDialogs();

        // --- UI Colors and Styling ---
        var orangeColor = [1, 0.5, 0]; // R, G, B for main accent
        var darkerOrangeColor = [0.8, 0.4, 0]; // A darker shade for specific text
        var greyColor = [0.6, 0.6, 0.6]; // Lighter grey for less emphasis
        var whiteColor = [1, 1, 1];
        var panelBackgroundColor = [0.18, 0.18, 0.18]; // Dark background for panels

        // --- UI Creation Section (Modernized) ---
        var mainWindow = new Window("palette", "Audio Cleaner V1 by EAT", undefined, { resizeable: true, dockable: true });
        mainWindow.orientation = "column";
        mainWindow.alignChildren = ["fill", "top"];
        mainWindow.spacing = 10;
        mainWindow.margins = 15;
        mainWindow.graphics.backgroundColor = mainWindow.graphics.newBrush(mainWindow.graphics.BrushType.SOLID_COLOR, [0.15, 0.15, 0.15]);


        // INSTRUCTIONS PANEL
        var instructionsPanel = mainWindow.add("panel", undefined, "How to Use:");
        instructionsPanel.orientation = "column";
        instructionsPanel.alignChildren = "left";
        instructionsPanel.margins = 12;
        instructionsPanel.spacing = 8;
        instructionsPanel.graphics.backgroundColor = instructionsPanel.graphics.newBrush(instructionsPanel.graphics.BrushType.SOLID_COLOR, panelBackgroundColor);
        instructionsPanel.graphics.foregroundColor = instructionsPanel.graphics.newPen(instructionsPanel.graphics.PenType.SOLID_COLOR, orangeColor, 1); // Orange Header
        var instruction1 = instructionsPanel.add("statictext", undefined, "1. Select the main video/still layer to edit.");
        var instruction2 = instructionsPanel.add("statictext", undefined, "2. Ensure an audio layer exists in the comp.");
        var instruction3 = instructionsPanel.add("statictext", undefined, "3. Adjust settings below and click 'Start'.");
        instruction1.graphics.foregroundColor = instruction1.graphics.newPen(instruction1.graphics.PenType.SOLID_COLOR, whiteColor, 1);
        instruction2.graphics.foregroundColor = instruction2.graphics.newPen(instruction2.graphics.PenType.SOLID_COLOR, whiteColor, 1);
        instruction3.graphics.foregroundColor = instruction3.graphics.newPen(instruction3.graphics.PenType.SOLID_COLOR, whiteColor, 1);


        // SETTINGS PANEL
        var settingsPanel = mainWindow.add("panel", undefined, "Audio Analysis Settings:");
        settingsPanel.orientation = "column";
        settingsPanel.alignChildren = ["fill", "top"];
        settingsPanel.spacing = 10;
        settingsPanel.margins = 12;
        settingsPanel.graphics.backgroundColor = settingsPanel.graphics.newBrush(settingsPanel.graphics.BrushType.SOLID_COLOR, panelBackgroundColor);
        settingsPanel.graphics.foregroundColor = settingsPanel.graphics.newPen(settingsPanel.graphics.PenType.SOLID_COLOR, whiteColor, 1); // White Header

        // PADDING SLIDER
        var paddingGroup = settingsPanel.add("group");
        paddingGroup.orientation = "row";
        paddingGroup.alignChildren = ["left", "center"];
        var paddingLabel = paddingGroup.add("statictext", undefined, "Audio Padding (Frames):");
        var slider = paddingGroup.add("slider", undefined, 5, 0, 60);
        slider.preferredSize.width = 100;
        var paddingValueText = paddingGroup.add("statictext", undefined, "5");
        paddingValueText.preferredSize.width = 30;
        slider.onChanging = function () {
            paddingValueText.text = Math.round(this.value);
        };

        // THRESHOLD SLIDER
        var thresholdGroup = settingsPanel.add("group");
        thresholdGroup.orientation = "row";
        thresholdGroup.alignChildren = ["left", "center"];
        var thresholdLabel = thresholdGroup.add("statictext", undefined, "Silence Threshold (dB):");
        var slider2 = thresholdGroup.add("slider", undefined, 1, 0, 10);
        slider2.preferredSize.width = 120;
        var thresholdValueText = thresholdGroup.add("statictext", undefined, "1.0");
        thresholdValueText.preferredSize.width = 30;
        slider2.onChanging = function () {
            thresholdValueText.text = this.value.toFixed(1);
        };
        
        // OPTIONS GROUP
        var optionsGroup = mainWindow.add("group");
        optionsGroup.orientation = "column";
        optionsGroup.alignChildren = "left";
        optionsGroup.spacing = 5;
        var check2 = optionsGroup.add("checkbox", undefined, "Keep Gaps (Don't ripple delete)");
        var check1 = optionsGroup.add("checkbox", undefined, "Invert (Process silent parts instead)");

        // DIVIDER
        var divider = mainWindow.add("panel");
        divider.alignment = "fill";
        divider.preferredSize.height = 2;
        divider.graphics.backgroundColor = divider.graphics.newBrush(divider.graphics.BrushType.SOLID_COLOR, [0.3, 0.3, 0.3]);

        // ACTION BUTTON
        var button = mainWindow.add("button", undefined, "Start Cleaning", { name: "ok" });
        button.alignment = "fill";
        button.preferredSize.height = 30;
        // Simple and clean button look, as ScriptUI customization is limited.

        // FOOTER
        var footerGroup = mainWindow.add("group");
        footerGroup.orientation = "column";
        footerGroup.spacing = 2;
        footerGroup.alignment = "center";
        var madeByText = footerGroup.add("statictext", undefined, "Made by EAT - Talha");
        var aiText = footerGroup.add("statictext", undefined, "more like ai");
        madeByText.graphics.foregroundColor = madeByText.graphics.newPen(madeByText.graphics.PenType.SOLID_COLOR, darkerOrangeColor, 1);
        aiText.graphics.foregroundColor = aiText.graphics.newPen(aiText.graphics.PenType.SOLID_COLOR, greyColor, 1);


        // --- UI Display Logic ---
        mainWindow.layout.layout(true);
        mainWindow.onResizing = mainWindow.onResize = function () {
            this.layout.resize();
        }
        
        if (mainWindow instanceof Window) {
            mainWindow.center();
            mainWindow.show();
        }

        // --- Button onClick Handler (Unchanged) ---
        button.onClick = function () {
            if (!comp || !(comp instanceof CompItem) || comp.numLayers < 1) {
                 alert("Please select a valid composition with at least one layer.");
                 return;
            }
            // Use the selected layer, or the top layer if none is selected
            layer = comp.selectedLayers.length > 0 ? comp.selectedLayers[0] : comp.layer(1);

            app.beginUndoGroup("Audio Cleaner V1");
            try {
                convertAudio();
                var keyInfo = calculateKeys();

                if (check1.value == true) { // Invert
                    if (check2.value == true) { // and Keep Gaps
                        editVideoReverseNoDelete(keyInfo[0], keyInfo[1]);
                    } else { // Just Invert
                        editVideoReverse(keyInfo[0], keyInfo[1]);
                    }
                } else { // Normal
                    if (check2.value == true) { // and Keep Gaps
                        editVideoNoDelete(keyInfo[0], keyInfo[1]);
                    } else { // Normal, Ripple Delete
                        editVideo(keyInfo[0], keyInfo[1]);
                    }
                }
                alert("Processing Complete!", "Audio Cleaner V1");
            } catch (e) {
                alert("An error occurred: " + e.toString() + "\n\nMake sure you have an audio layer in your composition and a layer to edit is selected.", "Audio Cleaner V1 Error");
            } finally {
                app.endUndoGroup();
            }
        };
        app.endSuppressDialogs(false);
    }
}
